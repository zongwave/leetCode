
<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>


# 数学算法专题总结

## 核心解题原则


---

## 题目

* [Math 数学算法总结](#LeetCode-math-总结)
  * [目录](#目录)
  * [9. 回文数字](#9-palindrome-number)
  * [231. 2的幂次数](#231-power-of-two)

---

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---

## 9. palindrome number

**判断一个整数是否正读反读相同（如121是回文，123不是），要求不使用字符串转换，直接操作数字。**  

**关键点**：  
- 负数直接排除  
- 通过数学运算反转一半数字进行比较  
- 注意处理以0结尾的非零数（如10）的特殊情况
---

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false;

        vector<int> temp;
        int num = x;
        while (num >= 10) {
            int mod = num % 10;
            num = num / 10;
            temp.push_back(mod);
        }
        temp.push_back(num);

        int bits = temp.size();
        for (int i = 0, j = bits - 1; i < j; i++, j--) {
            if (temp[i] != temp[j]) {
                return false;
            }
        }
        return true;
    }
};

```

你的代码实现了判断一个整数是否是回文数的功能，但有几个地方可以优化和改进。以下是详细分析和建议：

### 代码分析
1. **负数处理**：直接返回 `false`，正确。
2. **数字分解**：将数字逐位分解并存入 `vector`，然后比较首尾数字。
3. **回文判断**：使用双指针法比较数字是否对称。

### 存在的问题
1. **不必要的存储**：使用 `vector` 存储各位数字，增加了空间复杂度。
2. **边界条件**：`x = 0` 时也能正确处理，但可以更简洁。
3. **效率问题**：反转一半数字即可判断，不需要全部反转。

### 优化建议
1. **直接反转一半数字**：不需要存储所有位数，只需反转一半数字并与另一半比较。
2. **提前终止**：在反转过程中可以提前判断是否非回文。

### 优化后的代码
```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0 || (x % 10 == 0 && x > 0)) {
          return false;
        }

        int reverse = 0;
        while (reverse < x) {
          reverse = reverse * 10 + x % 10;
          x = x / 10;
        }

        // 偶数位：reversed == x
        // 奇数位：reversed/10 == x（去掉中间数字）
        return (reverse == x) || (reverse / 10 == x); 
    }
};
```

---
<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>


### 优化点说明
1. **负数和非零的10的倍数**：直接返回 `false`。
2. **反转一半数字**：
   - 当原始数字小于或等于反转后的数字时，表示已经处理了一半位数。
   - 例如：`1221`，反转后得到 `12` 和 `12`；`12321`，反转后得到 `12` 和 `123`，此时 `x == reversed / 10`。
3. **空间复杂度**：O(1)，不需要额外空间存储数字。

### 复杂度分析
- **时间复杂度**：O(log10(n))，因为每次迭代数字减少一位。
- **空间复杂度**：O(1)，只使用了常数空间。

### 测试用例
| 输入     | 预期结果 | 优化后代码 |
|----------|----------|------------|
| 121      | true     | true       |
| -121     | false    | false      |
| 10       | false    | false      |
| 0        | true     | true       |
| 12321    | true     | true       |
| 123456   | false    | false      |

### 总结
- **原始代码**：正确但不够高效，使用了额外的空间。
- **优化代码**：更高效，空间复杂度为 O(1)，逻辑更简洁。
- **推荐**：使用优化后的方法，更适合面试和实际应用。

---

## 231. Power of Two

### **总结：判断一个数是否是 2 的幂次方（Power of Two）**

#### **1. 初始解法（循环除法）**
**代码：**
```cpp
bool isPowerOfTwo(int n) {
    if (n <= 0) return false;
    while (n > 1) {
        if (n % 2 == 1) return false;
        n /= 2;
    }
    return true;
}
```
**特点：**
- **思路**：不断除以 2，如果最终得到 1，则是 2 的幂次方。
- **时间复杂度**：`O(log n)`（最坏情况需要 `log2(n)` 次循环）。
- **优点**：直观易懂，适合不熟悉位运算的情况。
- **缺点**：效率不如位运算高。

---

#### **2. 优化解法（位运算）**
**代码：**
```cpp
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```
**特点：**
- **思路**：利用 2 的幂次方的二进制特性（只有一个 `1`）。
- **时间复杂度**：`O(1)`（仅需一次位运算）。
- **优点**：极高效，是面试/竞赛中的最优解。
- **关键点**：
  - `n & (n - 1)` 会去掉最低位的 `1`，如果结果是 `0`，说明 `n` 只有一个 `1`。
  - 必须检查 `n > 0`，因为负数和 0 不是 2 的幂次方。

---

#### **3. 犯过的错误**
##### **错误 1：运算符优先级问题**
**错误代码：**
```cpp
return n > 0 && (n & (n - 1) == 0);  // 错误！
```
**问题：**
- `==` 的优先级高于 `&`，导致实际计算的是 `n & ((n - 1) == 0)`，逻辑错误。
**修正：**
```cpp
return n > 0 && ((n & (n - 1)) == 0);  // 正确
```

##### **错误 2：负数处理冗余**
**错误代码：**
```cpp
if (n >= 1) { /* 检查正数 */ }
else { /* 检查负数 */ }  // 无意义，2 的幂次方不可能是负数
```
**问题：**
- 2 的幂次方一定是正整数，无需检查负数部分。
**修正：**
```cpp
if (n <= 0) return false;  // 直接排除非正数
```

##### **错误 3：硬编码循环次数**
**错误代码：**
```cpp
for (int i = 0; i < 32; i++) { /* 检查 1<<i */ }
```
**问题：**
- 虽然能通过，但效率低（固定 32 次循环）。
**改进：**
- 用位运算或循环除法替代。

---

#### **4. 关键知识点**
1. **2 的幂次方的二进制特性**：
   - 只有一个 `1`，例如 `8 = 1000`。
   - `n & (n - 1) == 0` 是核心判断条件。
2. **边界条件**：
   - `n` 必须是正整数（`n > 0`）。
   - `n = 1` 是 `2^0`，需要特殊处理（但你的代码已覆盖）。
3. **位运算技巧**：
   - `n & (n - 1)`：去掉最低位的 `1`。
   - `n & -n`：直接获取最低位的 `1`（也可用于判断）。

---

#### **5. 最终推荐解法**
```cpp
bool isPowerOfTwo(int n) {
    return n > 0 && (n & (n - 1)) == 0;
}
```

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

**为什么推荐？**
- 时间复杂度 `O(1)`，空间复杂度 `O(1)`。
- 简洁、高效，适合面试和实际应用。

---

#### **6. 总结**
- **掌握位运算**：能大幅提升类似问题的解决效率。
- **注意运算符优先级**：必要时加括号明确优先级。
- **边界条件检查**：确保覆盖 `n <= 0` 的情况。
- **避免冗余逻辑**：如无必要，勿增实体（如负数检查）。

通过这道题，你巩固了 **位运算** 和 **边界条件处理** 的技巧，后续遇到类似问题（如判断 3/4 的幂次方）可举一反三！

---
<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---
