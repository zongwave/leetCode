
<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>


# 字符串算法专题总结

## 核心解题原则
1. **双向映射检查**：同构类问题必须验证两个方向的唯一性
2. **边界处理**：始终考虑空输入、长度不匹配等边界情况
3. **原地操作**：优先使用指针/迭代器减少内存开销

---

## 题目

* [String 字符串算法总结](#LeetCode-string-总结)
  * [目录](#目录)
  * [67. 二进制相加](#67-add-binary)
  * [125. 回文判断](#125-valid-palindrome)
  * [205. 同构字符串](#205-isomorphic-strings)
  * [290. 单词模板](#290-word-pattern)
  * [3. 最长无重复子串](#3-longest-substring-without-repeating-characters)
  * [13. 罗马数字字符串](#13-roman-to-integer)


---

## 67. Add Binary

  **给定两个二进制字符串，返回它们的和（二进制形式）**  
  *关键点：模拟进位操作，统一处理不同长度字符串*

---

### **你的原始代码问题总结**
你在实现**二进制字符串加法**时，主要存在以下几个问题：

---

#### **1. 初始化和逻辑错误**
- **错误**：初始字符串 `c = "0"` 不合理，后续直接 `append` 较长的字符串，导致结果前多一个 `'0'`。
  ```cpp
  string c = "0";  // 错误初始化
  if (aLen >= bLen) {
      c.append(a); // 结果会变成 "01010"（多一个前导0）
  }
  ```
- **影响**：最终结果可能包含错误的额外字符（如 `"01010"` 而不是 `"1010"`）。

---

#### **2. 循环条件和索引错误**
- **错误**：循环 `for (int i = 0; i < aLen && i < bLen; i++)` 只遍历较短字符串的长度，未处理较长字符串剩余部分。
  ```cpp
  // 错误：无法处理 a="100", b="1" 的情况（只会计算1位）
  for (int i = 0; i < aLen && i < bLen; i++) {
      // ...
  }
  ```
- **影响**：长字符串的高位会被忽略（如 `"100" + "1"` 会错误返回 `"000"`）。

---

#### **3. 进位处理不完整**
- **错误**：循环结束后未检查剩余的进位（如 `"1" + "1"` 应得 `"10"`，但你的代码可能返回 `"0"`）。
  ```cpp
  // 缺少对最终进位的处理
  if (carry) {
      res.push_back('1'); // 你的代码漏了这一步
  }
  ```
- **影响**：最高位的进位丢失。

---

#### **4. 字符与数字转换混淆**
- **错误**：混合使用 `a[i]` 和 `a[aLen-1-i]`，导致逻辑混乱。
  ```cpp
  // 错误：同一循环中混用正向和反向索引
  if (a[i] == '0' && b[i] == '0') { ... }       // 正向索引
  c[cLen - 1 - i] = ...;                        // 反向索引
  ```
- **影响**：计算结果完全错误。

---

### **正确方法**
#### **1. 从最低位开始计算**
- **关键点**：初始化指针 `i` 和 `j` 分别指向 `a` 和 `b` 的**最末尾**（最低位）。
  ```cpp
  int i = a.size() - 1, j = b.size() - 1;
  ```

#### **2. 逐位相加并处理进位**
- **步骤**：
  1. 计算当前位的和（`sum = a[i] + b[j] + carry`）。
  2. 当前位结果：`sum % 2`。
  3. 新进位：`sum / 2`。
  ```cpp
  while (i >= 0 || j >= 0 || carry) {
      int sum = carry;
      if (i >= 0) sum += a[i--] - '0'; // 字符转数字
      if (j >= 0) sum += b[j--] - '0';
      res.push_back('0' + (sum % 2));   // 数字转字符
      carry = sum / 2;
  }
  ```

#### **3. 反转结果**
- **原因**：计算时是从低位到高位存储，需反转得到高位在前的字符串。
  ```cpp
  reverse(res.begin(), res.end());
  ```

#### **4. 处理前导零（可选）**
- **优化**：如果结果为空或全零，返回 `"0"`。
  ```cpp
  return res.empty() ? "0" : res;
  ```

---

### **完整正确代码**
```cpp
#include <algorithm>
#include <string>

class Solution {
public:
    string addBinary(string a, string b) {
        string res;
        int i = a.size() - 1;
        int j = b.size() - 1;
        int carry = 0;

        while (i >= 0 || j >= 0 || carry == 1) {
            int sum = carry;
            if (i >= 0) sum += a[i--] - '0';
            if (j >= 0) sum += b[j--] - '0';

            carry = sum / 2;
            res.push_back(sum % 2 + '0');
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---

### **对比总结**
| 问题点          | 你的代码问题                          | 正确方法                          |
|-----------------|---------------------------------------|-----------------------------------|
| **初始化**      | 初始 `c="0"` 导致多余前导零           | 直接初始化空字符串 `res`          |
| **循环条件**    | 只遍历较短字符串                      | 遍历所有位 + 进位检查             |
| **索引方向**    | 混用正向和反向索引                    | 统一从最低位开始（`i = a.size()-1`）|
| **进位处理**    | 漏掉最高位进位                        | 循环结束后检查 `carry`            |
| **字符转换**    | 无显式转换，逻辑混乱                  | 用 `c - '0'` 和 `'0' + num` 明确转换 |

---

### **关键技巧**
1. **字符与数字转换**：
   - `'1' - '0' = 1`（字符转数字）
   - `'0' + 1 = '1'`（数字转字符）
2. **进位处理**：
   - `sum / 2` 是进位，`sum % 2` 是当前位。
3. **边界条件**：
   - 输入为 `"0" + "0"` 时，返回 `"0"`。

掌握这些后，类似题目（如十进制字符串加法）也能轻松解决！ 🚀

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>
---

## 125. Valid Palindrome

---
  **判断字符串在忽略大小写和非字母数字字符后是否为回文**  
  *关键点：双指针跳过无效字符，统一大小写比较*

---

### **你的原始解答问题总结**

#### **1. 字符过滤逻辑错误**
- **问题**：  
  你使用了错误的连续比较语法 `'a' <= c <= 'z'` 和 `'A' <= c <= 'Z'`，导致逻辑判断失效（C++不支持这种写法，会解析成 `(a <= c) <= z`，结果永远为 `true`）。  
- **影响**：  
  非字母数字字符可能被错误保留，导致回文判断错误。

#### **2. 数字字符被忽略**
- **问题**：  
  你的代码没有处理数字字符（`0-9`），而题目明确要求字母数字字符（包括数字）都应参与比较。  
- **影响**：  
  如 `"12321"` 会被误判为非回文。

#### **3. 大小写转换错误**
- **问题**：  
  大写字母转小写时错误地使用了 `c - 26`（应为 `tolower(c)` 或 `c + 32`）。  
- **影响**：  
  大小写字母无法正确匹配（如 `'A'` 和 `'a'` 会被视为不同字符）。

#### **4. 边界条件未处理**
- **问题**：  
  在跳过非字母数字字符时，未检查指针越界（如 `left++` 可能超出字符串范围）。  
- **影响**：  
  输入为全非字母数字字符（如 `"!!!"`）时，程序可能崩溃或返回错误结果。

---

### **正确解法**
#### **1. 双指针法（最优解）**
```cpp
#include <cctype> // 用于 isalnum 和 tolower

class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0, right = s.size() - 1;
        while (left < right) {
            // 跳过非字母数字字符（需检查边界）
            while (left < right && !isalnum(s[left])) left++;
            while (left < right && !isalnum(s[right])) right--;
            
            // 统一转小写后比较
            if (tolower(s[left]) != tolower(s[right])) return false;
            
            left++;
            right--;
        }
        return true;
    }
};
```

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>


#### **关键改进**
1. **正确过滤字符**：  
   - 使用 `isalnum(c)` 判断字母数字字符（包括数字）。  
   - 若需自定义 `isalnum`，逻辑应为：  
     ```cpp
     bool isalnum(char c) {
         return (c >= 'a' && c <= 'z') || 
                (c >= 'A' && c <= 'Z') || 
                (c >= '0' && c <= '9');
     }
     ```

2. **统一大小写**：  
   - 用 `tolower(c)` 将字母转为小写，数字不受影响。

3. **严格边界检查**：  
   - 在 `left++` 和 `right--` 前，确保 `left < right`，防止越界。

4. **提前终止**：  
   - 一旦发现不匹配字符，立即返回 `false`，提升效率。

#### **复杂度分析**
- **时间复杂度**：O(n)，只需遍历字符串一次。  
- **空间复杂度**：O(1)，无需额外存储。

---

### **测试用例验证**
| 输入 | 输出 | 说明 |
|------|------|------|
| `"A man, a plan, a canal: Panama"` | `true` | 过滤后为 `"amanaplanacanalpanama"` |
| `"race a car"` | `false` | 过滤后为 `"raceacar"` |
| `"12321"` | `true` | 纯数字回文 |
| `"0P"` | `false` | 过滤后为 `"0p"` |
| `"!!!"` | `true` | 全非字母数字视为空字符串 |

---

### **总结**
- **你的问题**：字符判断语法错误、数字遗漏、边界未处理。  
- **正确做法**：  
  1. 用 `isalnum` 过滤字符（或自定义正确逻辑）。  
  2. 双指针向中间移动，跳过无效字符后比较。  
  3. 统一转小写，确保大小写不敏感。  
  4. 严格检查指针边界，避免越界。  

此解法高效（O(n) 时间，O(1) 空间）且鲁棒性强，能处理所有边界情况。

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---

## 205. Isomorphic Strings

---

  **判断两个字符串能否通过字符的一一映射相互转换**  
  *关键点：双向哈希表检查字符映射唯一性*

---


### **你的错误总结与正确解法分析**

#### **一、你最初犯的错误**
1. **错误思路**：  
   - 你尝试统计字符出现次数，但题目要求的是**字符映射关系**，而非频率统计。  
   - 例如 `s = "abc"`, `t = "def"` 和 `s = "abc"`, `t = "xyz"` 的频率统计结果相同，但映射关系完全不同。

2. **忽略双向映射**：  
   - 你只考虑了 `s→t` 的映射，但题目要求**双射**（即 `t→s` 也必须一一对应）。  
   - **反例**：`s = "ab"`, `t = "aa"`  
     - 如果只检查 `s→t`，会误判为 `true`（`a→a`, `b→a`），但实际上 `t` 的 `a` 被 `s` 的 `a` 和 `b` 同时映射，违反规则。

3. **未正确处理顺序**：  
   - 题目要求字符替换必须**按顺序进行**，但你的方法可能忽略顺序约束。  
   - **反例**：`s = "abc"`, `t = "cba"`  
     - 字符集相同，但顺序不同，应返回 `false`。

---

#### **二、正确解答的逻辑分析**
##### **核心思路**
1. **双向映射检查**：  
   - 用两个哈希表分别记录 `s→t` 和 `t→s` 的字符映射关系。  
   - 确保：
     - `s` 的每个字符唯一映射到 `t` 的一个字符（`s→t` 不冲突）。
     - `t` 的每个字符唯一映射到 `s` 的一个字符（`t→s` 不冲突）。

2. **顺序一致性**：  
   - 遍历字符串时，**实时检查**当前字符的映射是否与之前记录的冲突。

##### **代码实现（C++）**
```cpp
#include <unordered_map>
#include <string>

using namespace std;

class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if (s.size() != t.size()) return false;

        unordered_map<char, char> s_to_t; // s→t 的映射
        unordered_map<char, char> t_to_s; // t→s 的映射

        for (int i = 0; i < s.size(); ++i) {
            char char_s = s[i], char_t = t[i];

            // 检查 s→t 是否冲突
            if (s_to_t.count(char_s) && s_to_t[char_s] != char_t) 
                return false;

            // 检查 t→s 是否冲突
            if (t_to_s.count(char_t) && t_to_s[char_t] != char_s) 
                return false;

            // 记录新映射
            s_to_t[char_s] = char_t;
            t_to_s[char_t] = char_s;
        }
        return true;
    }
};
```

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>


##### **关键步骤解析**
1. **初始化**：  
   - 两个哈希表 `s_to_t` 和 `t_to_s` 分别记录双向映射。

2. **遍历检查**：  
   - 对每个字符 `s[i]` 和 `t[i]`：
     - 如果 `s[i]` 已存在于 `s_to_t`，检查其映射是否等于 `t[i]`。
     - 如果 `t[i]` 已存在于 `t_to_s`，检查其映射是否等于 `s[i]`。

3. **冲突处理**：  
   - 任一方向映射冲突，立即返回 `false`。

4. **记录新映射**：  
   - 若无冲突，记录当前字符的映射关系。

5. **返回结果**：  
   - 全部字符通过检查后，返回 `true`。

---

#### **三、正确性验证**
##### **测试用例**
| `s`       | `t`       | 结果  | 原因分析                     |
|-----------|-----------|-------|-----------------------------|
| `"egg"`   | `"add"`   | `true`  | `e→a`, `g→d`，双向映射一致    |
| `"foo"`   | `"bar"`   | `false` | `o→a` 和 `o→r` 冲突          |
| `"paper"` | `"title"` | `true`  | `p→t`, `a→i`, `e→l`, `r→e`   |
| `"badc"`  | `"baba"`  | `false` | `d→b` 和 `a→b` 冲突（`t` 的 `b` 被重复映射） |

##### **为什么双向检查能解决问题？**
- **`s_to_t` 防止**：`s` 的多个字符映射到 `t` 的同一字符。  
  （如 `s="ab"`, `t="aa"` 中 `a→a` 和 `b→a` 冲突）
- **`t_to_s` 防止**：`t` 的多个字符映射到 `s` 的同一字符。  
  （如 `s="aa"`, `t="ab"` 中 `a→a` 和 `a→b` 冲突）

---

#### **四、总结**
- **你的错误**：  
  1. 混淆了频率统计与映射关系。  
  2. 忽略了双向映射的必要性。  
  3. 未严格处理顺序约束。

- **正确解法**：  
  1. 使用双向哈希表检查字符映射。  
  2. 实时验证顺序一致性。  
  3. 时间复杂度：O(n)，空间复杂度：O(1)（字符集大小固定）。  

通过双向映射检查，可以严格满足题目要求的**双射**和**顺序一致性**。

---
<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---

## 290. Word Pattern


---

  **判断字符串中的单词是否匹配给定字符的模式**  
  *关键点：字符与单词的双向映射检查，类似205题的扩展*

---

### 你解题过程中的错误总结与分析

#### 1. **初始错误分析**
你在解决这道题时主要出现了以下几个问题：

##### (1) **单词分割逻辑不完整**
- **错误表现**：最初使用`while (*idx != ' ' && *idx != '0')`来分割单词
- **问题**：
  - 字符串结尾是`\0`而非`'0'`，导致可能读取越界
  - 没有正确处理字符串末尾的空格或结束符
- **影响**：可能导致单词提取不完整或程序崩溃

##### (2) **变量混用和初始化问题**
- **错误表现**：同时使用`char* idx`和`int i`两种索引方式
- **问题**：
  - 指针和整型索引混用容易导致越界
  - 变量初始化顺序不合理（如`letter`提前初始化）
- **影响**：代码可读性差，潜在越界风险

##### (3) **边界条件处理不足**
- **错误表现**：未正确处理pattern和单词数量不匹配的情况
- **问题**：
  - 如`pattern="aaa"`, `s="aa aa aa aa"`应返回false但可能误判
  - 对空字符串输入的处理不明确
- **影响**：无法通过所有测试用例

##### (4) **单词缓存未清空**
- **错误表现**：`word`字符串在循环中未清空
- **问题**：导致后续单词错误累积（如第一个单词"dog"，第二个单词会变成"dogcat"）
- **影响**：映射检查完全失效

#### 2. **与Isomorphic Strings的关联性**
你受205. Isomorphic Strings启发的解法方向是合理的，因为：

| 相似点                | Isomorphic Strings       | Word Pattern          |
|-----------------------|--------------------------|-----------------------|
| **核心要求**          | 字符双向唯一映射          | 字符与单词双向唯一映射 |
| **数据结构**          | 两个哈希表                | 两个哈希表            |
| **检查逻辑**          | 双向映射冲突检测          | 双向映射冲突检测      |

但需要注意关键差异：
- **复杂度提升**：Word Pattern需要额外处理**单词分割**
- **边界条件**：字符串和pattern的长度比较更复杂

#### 3. **解法的最优性分析**
你的最终解法：

##### 优点：
1. **时间复杂度O(n)**：每个字符/单词只处理一次
2. **空间复杂度O(m)**：只需存储唯一字符和单词的映射
3. **正确处理了所有边界情况**：
   - pattern和单词数量不匹配
   - 空字符串输入
   - 双向映射冲突

##### 可能的优化空间：
1. **提前长度检查**：
   ```cpp
   // 可以先计算空格数+1是否等于pattern长度
   if (count(s.begin(), s.end(), ' ') + 1 != pattern.size()) 
       return false;
   ```
2. **使用string_view**：减少单词拷贝开销（C++17）
3. **并行处理**：同时进行单词分割和映射检查

##### 对比其他解法：
| 方法               | 时间复杂度 | 空间复杂度 | 优点                     | 缺点                     |
|--------------------|------------|------------|--------------------------|--------------------------|
| 你的双向哈希表法    | O(n)       | O(m)       | 逻辑清晰，正确处理所有情况 | 需要手动处理单词分割      |
| 单哈希表+编码法     | O(n)       | O(m)       | 代码简洁                 | 需要额外编码处理          |
| 暴力分割+比较       | O(n^2)     | O(n)       | 实现简单                 | 性能差，无法处理大规模数据|

#### 4. **总结建议**
1. **继续使用这种解法**：这是面试中最受认可的解决方案
2. **注意的改进点**：
   - 添加初始长度检查可提前返回
   - 使用`word.clear()`确保单词正确分割
   - 保持一致的变量命名风格
3. **扩展思考**：
   - 如何修改以支持Unicode？
   - 如果要求支持`pattern="abba"`, `s="dog cat cat dog dog"`该怎么办？

通过这道题，可将已有知识（Isomorphic Strings）合理迁移到新问题的能力，这是算法学习中非常重要的技能。

---
### **完整正确代码**
```cpp
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        int pattern_size = pattern.size();
        int s_size = s.size();

        int pattern_idx = 0;
        int s_idx = 0;

        string word;

        unordered_map<string, char> word_to_char;
        unordered_map<char, string> char_to_word;

        while (pattern_idx < pattern_size && s_idx < s_size) {

            while (s_idx < s_size && s[s_idx] != ' ') {
                word.push_back(s[s_idx++]);
            }
            if (s_idx < s_size) {
                s_idx++;
            }

            if (pattern_idx >= pattern_size) return false;
            
            char c = pattern[pattern_idx];

            if (word_to_char.count(word) && word_to_char[word] != c) {
                return false;
            }
            if (char_to_word.count(c) && char_to_word[c] != word) {
                return false;
            }
            word_to_char[word] = c;
            char_to_word[c] = word;

            pattern_idx++;
            word.clear();
        }

        return (pattern_idx == pattern_size && s_idx >= s_size);

    }
}


```

---

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---

## 3. Longest Substring Without Repeating Characters

### **「无重复字符的最长子串」问题总结**

#### **1. 问题描述**
给定一个字符串 `s`，找出其中**不包含重复字符**的**最长子串**的长度。

**示例**：
- 输入：`s = "abcabcbb"`  
  输出：`3`（最长无重复子串是 `"abc"`）

---

#### **2. 核心思路**
##### **滑动窗口（Sliding Window）**
- **窗口定义**：用两个指针 `[left, right]` 表示当前子串的左右边界。
- **核心操作**：
  1. **扩展右边界**：`right` 向右移动，将新字符纳入窗口。
  2. **收缩左边界**：当遇到重复字符时，`left` 直接跳到重复字符的下一个位置（利用哈希表记录字符最后出现的位置）。
- **关键点**：通过哈希表（`unordered_map`）存储字符的最后出现位置，实现 O(1) 时间的重复检查。

##### **算法步骤**
1. 初始化 `left = 0`，`max_len = 0`，哈希表 `last_seen`。
2. 遍历字符串：
   - 若当前字符 `s[right]` 已存在于 `last_seen` 且其位置 ≥ `left`，则移动 `left` 到 `last_seen[s[right]] + 1`。
   - 更新 `last_seen[s[right]] = right`。
   - 计算当前窗口长度 `right - left + 1`，更新 `max_len`。
3. 返回 `max_len`。

---

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---

#### **3. 最优解法代码（C++）**
```cpp
#include <unordered_map>
using namespace std;

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> last_seen;
        int left = 0;
        int max_len = 0;
        int s_len = s.size();

        for (int right = 0; right < s_len; right++) {
            char c = s[right];
            if (last_seen.count(c) && last_seen[c] >= left) {
                left = last_seen[c] + 1;
            }
            last_seen[c] = right;
            max_len = max(max_len, right - left + 1);
        }
        return max_len;
    }
};
```

---

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---

#### **4. 时间复杂度与空间复杂度**
- **时间复杂度**：**O(n)**，每个字符最多被访问两次（`left` 和 `right` 各一次）。
- **空间复杂度**：**O(min(m, n))**，其中 `m` 为字符集大小（ASCII 为 O(1)，Unicode 为 O(n)）。

---

#### **5. 关键优化点**
1. **哈希表跳跃**：发现重复时直接移动 `left`，避免逐字符收缩窗口。
2. **边界处理**：
   - 空字符串返回 `0`。
   - 全重复字符串（如 `"aaaa"`）返回 `1`。
3. **字符集选择**：
   - 若字符范围明确（如 ASCII），可用 `int[128]` 替代哈希表，进一步优化速度。

---

#### **6. 常见错误**
- **错误1**：未正确处理 `left` 的回跳（如 `"abba"` 中第二个 `'a'` 需确保 `left` 不后退）。
- **错误2**：忽略非字母字符（如空格、数字等）。
- **错误3**：用 `vector` 替代哈希表但未初始化值（导致误判）。

---

#### **7. 相似题目拓展**
1. [159. 至多包含两个不同字符的最长子串](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/)
2. [340. 至多包含 K 个不同字符的最长子串](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/)
3. [904. 水果成篮](https://leetcode.com/problems/fruit-into-baskets/)（滑动窗口变种）

---

#### **8. 总结**
- **核心技巧**：滑动窗口 + 哈希表记录位置。
- **面试重点**：解释清楚窗口收缩的优化逻辑（直接跳跃 `left`）。
- **变种思路**：若字符集有限，用数组替代哈希表；若需支持 Unicode，需调整键类型为 `string`。

通过这道题，可以深刻理解 **滑动窗口** 和 **哈希表优化** 的配合使用，是处理子串/子数组问题的经典范式。

---

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

---


## 13. Roman to Integer


#### **你的解法（反向遍历）遇到的问题**
1. **边界条件处理错误**
   - 你从 `i = s.size() - 1` 开始反向遍历，循环条件是 `i > 0`，但最后又单独加 `s[0]`。
   - **问题**：如果 `s[0]` 已经被减法规则处理过（如 `"IV"` 中的 `I`），会导致重复计算。
   - **示例**：`"IV"` → 正确值 `4`，但你的代码会计算 `V - I = 4` 后又加 `I`，得到 `5`（错误）。

2. **字符跳过逻辑不严谨**
   - 在反向遍历中，遇到 `s[i] > s[i-1]` 时，你会 `i--` 跳过前一个字符，但循环本身也会 `i--`，可能导致漏算或重复算。
   - **示例**：`"MCMXCIV"` 的正确值是 `1994`，但你的代码会得到 `1105`（因 `M` 被重复计算）。

3. **反向遍历的冗余性**
   - 罗马数字没有“位数”概念，反向遍历并不能简化问题，反而增加复杂度。

---

#### **最优解（正向遍历）**
##### **核心思路**
1. **从左到右遍历字符串**，依次处理每个字符。
2. **比较当前字符 `s[i]` 和下一个字符 `s[i+1]`**：
   - 如果 `s[i] < s[i+1]`，说明是减法组合（如 `IV`），减去 `s[i]` 的值。
   - 否则，直接加上 `s[i]` 的值。
3. **无需跳过字符或处理复杂边界**，逻辑清晰。

##### **代码实现**
```cpp
class Solution {
public:
    int romanToInt(string s) {
        unordered_map<char, int> roman = {
            {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50},
            {'C', 100}, {'D', 500}, {'M', 1000}
        };
        int res = 0;

        for (int i = 0; i < s.size(); i++) {
            if (i < s.size() - 1 && roman[s[i]] < roman[s[i+1]]) {
                res -= roman[s[i]];
            } else {
                res += roman[s[i]];
            }
        }
        return res;
    }
};
```

---

<a href="#题目" style="font-size: 16px; color: #666;">▲ 返回题目</a>

##### **执行流程示例（`s = "MCMXCIV"`）**
| 当前字符 | 下一个字符 | 操作              | 结果  |
|----------|------------|-------------------|-------|
| 'M' (1000) | 'C' (100) | 1000 > 100 → +1000 | 1000  |
| 'C' (100) | 'M' (1000) | 100 < 1000 → -100  | 900   |
| 'M' (1000) | 'X' (10)  | 1000 > 10 → +1000  | 1900  |
| 'X' (10)  | 'C' (100) | 10 < 100 → -10     | 1890  |
| 'C' (100) | 'I' (1)   | 100 > 1 → +100     | 1990  |
| 'I' (1)   | 'V' (5)   | 1 < 5 → -1         | 1989  |
| 'V' (5)   | -         | 无下一个字符 → +5  | 1994  |

**结果正确**：`1994`。

---

### **关键对比**
| 方案         | 逻辑清晰度 | 边界处理 | 字符跳过 | 适合罗马数字规则 |
|--------------|------------|----------|----------|------------------|
| 正向遍历     | ⭐⭐⭐⭐⭐   | 无需处理 | 无需跳过 | ⭐⭐⭐⭐⭐         |
| 反向遍历     | ⭐⭐       | 复杂     | 需跳过   | ⭐⭐              |

---

### **总结**
1. **你的错误**：反向遍历导致边界条件复杂，字符跳过逻辑不严谨。
2. **最优解**：正向遍历直接匹配罗马数字的书写规则，减法规则通过比较相邻字符即可实现。
3. **核心技巧**：
   - 用哈希表存储符号到值的映射。
   - 遍历时检查当前字符和下一个字符的关系，决定加减。

**推荐始终使用正向遍历**，避免不必要的复杂性！